# Blueprint: Preserve pnpm symlink structure

## Current Approach (dereference)

```
1. Trace files → get paths including symlinks
2. Copy with dereference: true → symlinks become real directories
3. Problem: nested deps lose their sibling relationship
4. Fix: derive and add root-level paths
```

## Proposed Approach (preserve symlinks)

```
1. Trace files → get paths including symlinks
2. Separate files into: real files vs symlinks
3. Copy real files first
4. Copy symlinks second (preserving as symlinks)
5. Result: structure preserved, resolution works naturally
```

## Why It Works

The tracer already returns both:
- `node_modules/sea-turtle` (symlink)
- `node_modules/.pnpm/sea-turtle@1.0.0/node_modules/sea-turtle/index.js` (real file)
- `node_modules/.pnpm/sea-turtle@1.0.0/node_modules/sea-turtle-shell` (symlink)
- `node_modules/.pnpm/sea-turtle-shell@1.0.0/node_modules/sea-turtle-shell/index.js` (real file)

Symlinks use **relative paths** (e.g., `.pnpm/sea-turtle@1.0.0/...`). When copied to the artifact, these relative paths still resolve correctly because the target directories are also copied.

## Implementation

### Single pass: copy each file appropriately

```typescript
await Promise.all(relativeFilePaths.map(async (filePath) => {
  const srcPath = absolutePath(filePath);
  const destPath = `${targetDirectory}/${filePath}`;

  // create parent directory
  await fs.promises.mkdir(dirname(destPath), { recursive: true });

  // check if symlink
  const stat = await fs.promises.lstat(srcPath);

  if (stat.isSymbolicLink()) {
    // preserve symlink as-is (relative target still valid in artifact)
    const linkTarget = await fs.promises.readlink(srcPath);
    await fs.promises.symlink(linkTarget, destPath);
  } else {
    // copy real file/directory
    await fs.promises.cp(srcPath, destPath, { recursive: true });
  }
}));
```

No classification step needed - just handle each file based on its type.

## Result

**Artifact structure:**
```
node_modules/
  sea-turtle/ → .pnpm/sea-turtle@1.0.0/node_modules/sea-turtle
  .pnpm/
    sea-turtle@1.0.0/
      node_modules/
        sea-turtle/
          index.js
        sea-turtle-shell/ → ../../sea-turtle-shell@1.0.0/node_modules/sea-turtle-shell
    sea-turtle-shell@1.0.0/
      node_modules/
        sea-turtle-shell/
          index.js
```

Node.js resolution works exactly as it did in the source project.

## Trade-offs

| Aspect | Dereference + Add Roots | Preserve Symlinks |
|--------|------------------------|-------------------|
| Artifact size | Larger (duplicated files) | Smaller (symlinks) |
| Complexity | Derive root paths | Order-dependent copy |
| Lambda compat | Works | Works (confirmed) |
| Debugging | Flat structure, easy to inspect | Nested structure, follows symlinks |

## Research: Lambda Symlink Support

**Confirmed: AWS Lambda supports symlinks in zip archives.**

From [terraform-aws-modules/terraform-aws-lambda#596](https://github.com/terraform-aws-modules/terraform-aws-lambda/issues/596):

> "counter to some misinformation online, AWS Lambda itself does support this"

The issue is not with Lambda, but with tooling that creates zip archives. Many tools dereference symlinks by default.

### Zipping with symlinks preserved

Use the `--symlinks` or `-y` flag:

```bash
zip --symlinks -r artifact.zip contents/
```

### Caveats

1. **Node.js zip libraries** - Most don't support symlinks. May need to shell out to system `zip`.
2. **Python's zipfile** - Doesn't preserve symlinks. Use subprocess to call system `zip`.
3. **Cross-platform** - Works on Linux (Lambda's OS). Windows may not preserve on extract.

## Implementation Update

### Current zip implementation

From `src/logic/containers/zipArtifactContents.ts`:

```typescript
import archiver from 'archiver';

const zipDirectory = ({ source, destination }) => {
  const archive = archiver('zip', { zlib: { level: 9 } });
  const stream = fs.createWriteStream(destination);
  archive.directory(source, false).pipe(stream);
  archive.finalize();
};
```

### Archiver symlink support

Archiver **does support symlinks** ([docs](https://www.archiverjs.com/docs/archiver/)):
- Has `symlink(filepath, target, mode)` method for programmatic symlink creation
- The `directory()` method detects symlinks via `stats.isSymbolicLink()` and sets `type: 'symlink'`

However, [GitHub issue #402](https://github.com/archiverjs/node-archiver/issues/402) suggests `directory()` may not handle symlinks correctly in all cases.

### Approach

1. **First:** Test if current `archiver.directory()` preserves symlinks correctly
   - May already work - need to verify

2. **Fallback:** Shell out to system `zip` command if archiver doesn't work
   ```typescript
   execSync(`zip --symlinks -r ${zipPath} .`, { cwd: contentsDir });
   ```

## Recommendation

Preserve symlinks approach is viable and preferred because:
- Smaller artifact size
- Natural Node.js resolution (no derived paths needed)
- Lambda confirmed to support it
